Re  Are bad developer libraries the problem with M  software No  you need to learn how declarations work in C   You have specified testbuff as  an array of      pointers to characters    That means  you have allocated an array big enough to store      pointers   On most machines  that s   bytes per pointer  which indeed would give you        John  On Fri  Nov          at         PM        Ali Saifullah Khan wrote    Here is a test done on the return of sizes by sizeof   using pointers        include        int main void       char  testbuff              int len   sizeof testbuff      cout    return             c  debug testbuff             The output from this is      but infact it should be returning         Apparently  using a pointer has multiplied the value of the original size of   the testbuff   buffer by the size of the   pointer          char pointers have a size of   bytes     as is shown when output is   bytes   using   int len   sizeof  char  testbuff          c  debug testbuff          so sizeof is returning the size of the  first  entity passed to it  that   being the size of the pointer             Whats confusing is when sizeof outputs the value for something like   char     testbuff       Here the macro seems to be multiplying the sizes of entities passed to it    by considering the first entity as the pointer denoted by the asterisk   itself        and then taking this value of   and multiplying it with the   size of the buffer testbuff   which is       to produce an output of            Rather strange behaviour              Original Message         From      To      Cc      Sent  Tuesday  November               AM   Subject  Re  Are bad developer libraries the problem with M  software                  Original Message           From  John Viega     Sent                     PM     To        Cc        Subject  Re  Are bad developer libraries the problem with M  software            strlen does not work  because he was trying to get at the ALLOCATED       size of a buffer  not the actual size of the buffer          You re right  I was looking at the safe strncpy code  and it looks like   the author did use strlen            sizeof will return the size of the data type passed to it   So if you       declared mystr as char mystr         it will return as the original       author wanted          It will not work with a char   so if your strings are dynamically   allocated  or passed to you as a pointer  these macros will not work                    